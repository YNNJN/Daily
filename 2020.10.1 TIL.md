# 네트워크

> - OSI 7계층, 브라우저에 화면이 뜨기까지의 과정, URI vs URL vs URN
> - TCP/IP, TCP와 UDP
> - HTTP, HTTPS, HTTP1.0, HTTP1.1, HTTP2.0
> - GET, POST, REST API





## 1. OSI 7계층

> OSI : Open Systems Interconnection
>
> ISO가 1970년대에 만든 네트워크 커뮤니케이션 표준을 의미함



| #    | 이름            | 주소                              | 데이터단위                       | 하는 일                                                      |
| :--- | :-------------- | :-------------------------------- | :------------------------------- | :----------------------------------------------------------- |
| 7    | **Application** | Application Specific              |                                  | 네트워크 자원 접근 가능하게                                  |
| 6    | Presentation    |                                   |                                  | 데이터 해석, 암호화, 압축                                    |
| 5    | Session         |                                   | Message                          | Session 열기, 관리, 닫기                                     |
| 4    | **Transport**   | PORT (TCP/UDP) 2byte              | Segment(TCP), User Datagram(UDP) | 신뢰성 있는 **Process-to-Process** 메시지 전송과 에러 복구   |
| 3    | **Network**     | IP (Logical) 4byte(v4)/16byte(v6) | Datagram(패킷)                   | 인터넷 작동을 위해 **패킷**을 목적지로 보냄                  |
| 2    | **Data Link**   | Mac (Physical) 6byte              | Frame                            | Hop-to-Hop 전송을 위해 비트들을 **프레임**으로 관리          |
| 1    | **Physical**    |                                   | Bit                              | **비트**를 매체(Medium)를 통해 전송, 기계적, 전자적 능력 필요 |



### OSI 모델을 이용한 데이터 교환

- In-Capsulation : 데이터에 헤더를 붙여 패킷으로 만든 후 하위 레이어로 보냄
- De-Capsulation : 데이터에서 헤더를 떼면서 상위 레이어로 보냄





## 2. 브라우저에 화면이 뜨기까지의 과정

> "Chrome을 실행시켜 주소창에 특정 URL 값을 입력하면 어떤 일이 일어나는가?"



### 1) 브라우저

1. URL에 입력된 값을 브라우저 내부의 규칙에 따라 의미를 조사함
2. 조사된 의미에 따라 **HTTP Request** 메시지를 생성함
3. 만들어진 메시지를 웹 서버로 전송함
   - 이 때 만들어진 메시지를 웹 서버로 브라우저가 직접 전달하는 것이 아닌 OS 커널 함수를 통해 전달함
   - **DNS 서버를 조회하여 IP 주소**를 알아옴



### 2) 프로토콜 스택, LAN 어댑터

> 프로토콜 스택이란 TCP/IP Protocol suite의 5 계층(Application, Transport, Network, Data-link, Physical)을 말함

1. 프로토콜 스택(OS의 내장 네트워크 제어 SW)이 브라우저로 부터 메시지를 받음
2. **Transport Layar**에서는 Port 번호 등 정보를 붙여 TCP Segment 패킷으로 변환함 (HTTP이므로 TCP 80번 포트 사용)
3. **Routing Table**을 이용하여 다음 Hop(라우터나 허브)의 IP 주소를 알아냄
4. **ARP**를 통해 보내야할 라우터의 MAC 주소를 알아와 패킷을 Frame으로 변환함
5. **MTU** 테이블을 참조하여 패킷을 Fragmentation 하고 패킷을 송신함
6. Physical 레이어의 기계적 요소들을 통해 Frame을 Bit 전기 신호로 변환하여 LAN 케이블을 통해 신호를 송신함



### 3) 허브, 스위치, 라우터

1. LAN 어댑터가 송출한 패킷이 스위칭 허브를 경유하여 인터넷 접속용 라우터에 도착함
2. 라우터는 **라우팅 테이블**을 보고 다음 Hop의 IP 주소를 알아냄
3. 이후 라우터는 **ARP**를 통해 다음 IP 주소에 해당하는 MAC 주소를 알아옴
4. **MTU** 테이블을 참조하여 패킷을 Fragmentation 하고 패킷을 송신함
5. 이후 패킷을 스위칭 허브 등을 통해 ISP(Internet Service Provider)에게 전달하게되면, 패킷이 인터넷으로 송신됨



### 4) 액세스 회선, 프로바이더

1. 패킷은 인터넷 입구의 액세스 회선에 의해 POP(Point Of Presence, 통신사용 라우터)까지 운반됨
2. POP를 거쳐 인터넷 핵심부로 패킷이 이동함
3. 다수의 라우터를 거쳐가며 목적지까지 패킷이 전송됨 (라우팅과 포워딩)



### 5) 방화벽, 캐시 서버

1. 패킷은 원래 목적지인 웹서버의 LAN에 도착함
2. 웹 서버의 방화벽이 도착한 패킷을 검사함
3. 중간에 패킷이 웹서버까지 가야하는지 가지 않아도 되는지 판단하는 캐시서버가 존재함



### 6) 웹 서버

1. 패킷이 물리적인 웹 서버에 도착하면 프로토콜 스택을 따라 웹 서버의 어플리케이션 프로그램에 패킷이 전달됨
2. 웹 서버에서 패킷을 받으면 **Network 레이어**에서 먼저 패킷이 Valid한지 검사한 후 Valid하지 않으면 패킷을 버리고, 그렇지 않다면 디팩키징하고 Fragment들을 저장해 놓음. 그 후 모든 Fragment가 도착하면 Fragment를 합쳐 Transport 레이어에 전달해줌. 만약 이 과정에서 Reassembly timer가 다된다면 모든 패킷을 버림.
3. **Transport 레이어**에 도착한 패킷은 TCP의 역할에 따라 패킷을 Checksum으로 검사하고, Error, Flow, Congestion 컨트롤을 수행함. 만약 모든 패킷이 올바르게 왔다면 패킷을 Application 레이어로 올림.
4. **Application 레이어**에서는 실제 프로그램이 해당 패킷을 받아 사용함.
5. 원래 요청이 왔던 브라우저에게 다시 **HTTP Response 메시지**를 보냄. 이때 이전 과정과 동일하게 전송됨.





## 3. URI vs URL vs URN

> 클라이언트 프로그램은 URI로 자원의 위치를 찾음
>
> HTTP는 전송 프로토콜, URI는 자원의 위치를 알리기 위한 프로토콜

- **URI** (Uniform Resource Identifier) : 정보 리소스를 고유하게 식별하고 위치를 지정함

  - **URL** (Uniform Resource Locator) : 특정 서버의 한 리소스에 대한 구체적인 위치를 서술함

  - **URN** (Uniform Resource Name) : 어떠한 리소스에 대해 위치에 영향을 받지 않는 유일무이한 이름을 지정함
    - URL의 단점을 보완하기 위해 탄생함
      - 도메인 주소가 바뀌거나 위치가 바뀌면 동시에 해당 URL은 잘못된 정보를 가리키거나, 잘못되 주소가 되는 등 단점이 있는 문제 





## 4. TCP/IP

> 인터넷과 관련된 프로토콜 집합의 총칭을 의미함
>
> "데이터의 순서가 바뀌지 않으면서 데이터가 유실되지 않도록 가급적 빠르게 데이터를 보내려면 네트워크 프로토콜을 어떻게 설계해야 할까?" 에 대한 고민으로 시작



### 프로토콜

- 약속 about
  - 케이블 규격
  - IP 주소 지정방법
  - 떨어진 상대를 찾기 위한 방법
  - 그곳에 도달하는 순서
  - 웹을 표시하기 위한 순서



### 4계층

> 계층화에 의한 메리트
>
> - 사양이 변경되면 해당 계층만 바꾸면 됨
> - 설계가 편함 (해당 계층이 담당하는 부분만을 고려)



#### 애플리케이션 계층

> 유저에게 제공되는 애플리케이션에서 사용하는 통신의 움직임을 결정함

#### 트랜스포트 계층

> 애플리케이션 계층에 네트워크로 접속되어 있는 2대의 컴퓨터 사이의 데이터 흐름을 제공함

#### 네트워크 계층

> 네트워크 상에서 패킷 (전송하는 데이터의 최소 단위) 의 이동을 다룸

#### 링크계층

> 네트워크에 접속하는 하드웨어적 면을 다룸





### 통신의 흐름

> 송신측은 계층을 통과할 때마다 헤더를 추가함
>
> 수신측은 계층을 통과할 때마다 헤더를 삭제함



1. 송신측 클라이언트의 **애플리케이션 계층 (HTTP)**
   - HTTP 리퀘스트 지시 - 어떤 웹 페이지 보고싶어
2. 송신측 클라이언트의 **트랜스포트 계층 (TCP)**
   - HTTP 메시지를 통신하기 쉽게 조각내어 안내번호와 포트번호를 붙여 전달
3. 송신측 클라이언트의 **네트워크 계층 (IP)**
   - 수신지 MAC 주소를 추가해서 전달
     - MAC 주소: Media Access Control Address
     - IP주소는 각 노드에 부여된 주소를 가리키고 MAC 주소는 각 네트워크 카드에 할당된 고유의 주소
4. 수신측 서버의 **링크 계층**
   - 데이터를 받아들여 순서대로 위의 계층에 전달하여 애플리케이션 계층까지 도달
5. 수신측 서버의 **애플리케이션 계층**
   - 클라이언트가 발신했던 HTTP 리퀘스트를 수신





## 5. TCP와 UDP

> 트랜스포트 계층의 서로 다른 성질을 가진 두 가지 프로토콜



### TCP

> User Datagram Protocol
>
> 대용량의 데이터를 보내기 쉽게 작게 분해하여 상대에게 보내고, 정확하게 도착했는지 확인함

- 연결형 프로토콜
  - `TCP 3-way Handshake`를 통해 연결 설정함
- 순서가 보존됨 (따로 순서와 전송 등을 관리하기 때문)
- TCP 서비스는 송신자와 수신자 모두가 소켓이라고 부르는 종단점을 생성함으로써 이루어짐

- 신뢰성과 순차적인 전달의 필요에 의해 탄생함



### UDP

> Transmission Control Protocol
>
> 포트들을 사용하여 IP 프로토콜에 인터페이스를 제공함

- 비연결형 프로토콜
  - IP 데이터 그램을 캡슐화하여 보내는 방법과 연결 설정을 하지 않고 보내는 방법을 제공함
- 순서가 보존되지 않음 (따로 관리 안 함)

- 클라이언트가 서버로 짧은 요청을 보내고, 짧은 응답을 기대하는 상황에서 사용함
- 코드가 간단하고, 초기설정에서 요구되는 프로토콜보다 적은 메시지가 요구됨



#### TCP 3-way Handshake

> 데이터를 상대방에게 확실하게 보내기 위해서 사용함
>
> 패킷을 보내고, 잘 보내졌는지 여부를 상대에게 확인하러 감 ('SYN'와 'ACK'라는 TCP 플래그를 사용)

1. 송신측에서 최초 'SYN' 플래그로 상대에게 접속함과 동시에 패킷을 보냄
2. 수신측에서는 'SYN/ACK' 플래그로 송신측에 접속함과 동시에 패킷을 수신한 사실을 전함
3. 마지막으로 송신측이 'ACK' 플래그를 보내 패킷 교환이 완료되었음을 전함



#### 바이트 스트림 서비스

> 용량이 큰 데이터를 보내기 쉽게 TCP 세그먼트라고 불리는 단위 패킷으로 작게 분해하여 관리하는 것





## 6. HTTP, HTTPS, HTTP1.1, HTTP2.0

> HTTP(Hypertext Transfer Protocol)은 WWW에서 데이터에 접근하기 위한 주된 프로토콜



### HTTP

- TCP 80번 포트를 사용함
- 데이터를 전송하는 데 Hypertext (쉽게 말해 링크, URL or URI) 기반으로 전송함
- 클라이언트/서버 모델을 따름
- `Connectless`
  - 요청 시 접속을 하고 응답을 보낸 후 접속이 끊어짐
  - 장점 : 불특정 다수를 대상으로 하는 서비스에서는 접속 유지를 최고한으로 할 수 있음
  - 단점 : 연결이 끊어지면 클라이언트의 이전 상태를 서버가 알 수 없음 (`Stateless`)
    - 이를 쿠키나 세션을 이용해 관리함



### HTTP vs HTTPS

> HTTPS는 Hypertext Transfer Protocol over Secure Socket Layer
>
> 모든 통신 내용을 암호화함

- HTTP가 TCP 80번 포트를 쓰는 것에 비해, HTTPS는 TCP 443번 포트를 이용함
- HTTPS는 SSL(Secure Socket Layer) 위에서 이루어지는 HTTP라 생각할 것
- HTTPS는 HTTP에 비해 속도가 많이 느리기 때문에, 민감한 정보를 다루는 페이지는 HTTPS로 속도가 중요한 페이지는 HTTP로 전송하기도 함
- HTTPS에서 SNI로 호스트 이름을 알 수 있음



### HTTP 1.1

> 연결 하나 당 하나의 요청과 응답을 처리

- 성능 이슈 존재
  - 이유 : 1. 동시 전송 2. 다수 리소스 처리
  - HOL(Head Of Line) Blocking : 스트림의 첫 패킷의 처리 과정이 느려짐에 따라 뒤의 패킷들 처리도 느려짐
  - RTT(Round Trip Time)가 증가함
  - Header구조가 무거움



### HTTP 2.0

> Multiplexed Streams, 한 커넥션에 여러 개의 메세지를 동시에 주고 받음

- 성능 획기적 향상
  - Stream Prioritization (요청 리소스 간 우선 순위 설정)
  - Header Compression (Header 정보를 HPACK 압축 방식으로 압축 전송)





## 7. 쿠키, 세션

### 쿠키

> - 쿠키로 클라이언트 로컬에 키와 값 등 데이터들을 저장해놓고 참조함 (이유 : HTTP가 Stateless)
> - 클라이언트는 쿠키를 사용자가 따로 요청하지 않아도 request 시에 request header를 넣어서 자동으로 서버에 전송함
> - 브라우저가 닫히더라도 쿠키는 파일 형태로 남아있음

- 자동 로그인, 장바구니 등에서 사용
- 클라이언트는 쿠키를 300개까지 가질 수 있고, 하나의 도메인 당 20개의 값만 가질 수 있음
- 하나의 쿠키 값은 4kb까지 저장



### 세션

> - 일정 시간 동안 같은 브라우저에서 들어오는 일련의 요구를 하나의 상태로 보고 상태를 유지하는 기술
> - 클라이언트가 서버에 request를 보내면 서버가 클라이언트에게 유일한 ID를 부여하게 되는데, 이것이 세션 ID
> - 쿠키와 다르게 세션은 서버에 저장됨. 브라우저가 닫히면 세션도 종료됨

1. 클라이언트가 서버에 접속을 하면 서버가 세션 ID를 발급해서 클라이언트에 전송함
2. 서버에서 세션 ID를 쿠키를 통해 저장함
3. 클라이언트는 다시 접속할 경우 쿠키를 이용하여 세션 ID를 서버에 전송함

- 로그인 정보 유지 등에서 사용



### 쿠키 vs 세션

- **라이프 사이클** : 세션은 브라우저가 닫히면 끊기고, 쿠키는 파일 형태로 남아 있음
- **보안** : 쿠키가 클라이언트에 저장되는데 비해, 세션은 서버에 저장되기에 좀 더 안전함
- **속도** : 쿠키는 클라이언트에서 서버로 보내기만 하면되지만, 세션은 서버에서 처리 후 클라이언트로 보내야하기 때문에 좀 더 느림
- **캐시**와는 다름 : 캐시는 브라우저 내에서 CSS, 이미지 등을 캐싱하고 있다가, 같은 요청이 오면 브라우저를 참고해서 불러오기 때문에 데이터 절약효과를 내고 속도를 빠르게하지만, 이는 쿠키나 세션과는 다름





## 8. GET, POST

> HTTP 프로토콜을 이용하여 서버에 요청할 때 사용하는 방식



### GET

> 요청하는 데이터가 `HTTP Request Message`의 Header 부분의 url에 담겨서 전송됨

- Url 상의 `?` 뒤에 데이터가 붙어 request를 보냄
- Url 이라는 공간에 담겨가기 때문에 전송할 수 있는 데이터의 크기가 제한적
- 데이터가 그대로 Url 에 노출되므로 보안이 필요한 데이터에 대해서는 적절하지 않음

### POST

> 요청하는 데이터가 `HTTP Request Body` 부분에 담겨서 전송됨

- 데이터의 크기가 GET 방식보다 크고 보안면에서 나음
  - 바이너리 데이터 요청 시 POST 방식 이용해야



### GET vs POST

#### GET

- 가져오는 것. 즉 SELECT의 성향
  - 서버에서 어떤 데이터를 가져와서 보여줌
  - 서버의 값이나 상태를 변경하지는 않음
- GET 방식의 요청은 브라우저에서 Caching 할 수 있음
  - POST 방식으로 요청해야 할 것을 데이터의 크기가 작고 보안 문제가 없다는 이유로 GET 방식으로 요청한다면 기존에 Caching 되었던 데이터가 요청될 가능성이 존재함 (목적에 맞는 기술 사용의 필요)

#### POST

- 서버의 값이나 상태를 변경하기 위해, 또는 추가하기 위해 사용함





## REST API

> Representational State Transfer
>
> 로이 필딩이 웹(HTTP)의 장점을 최대한 활용할 수 있는 아키텍처로서 REST를 발표함



### 구성

- **자원(RESOURCE)** - URI
- **행위(Verb)** - HTTP METHOD
- **표현(Representations)**



### 특징

#### 1) Uniform (유니폼 인터페이스)

- URI로 지정한 리소스에 대한 조작을 통일되고 한정적인 인터페이스로 수행하는 아키텍처 스타일임



#### 2) Stateless (무상태성)

- 상태정보를 따로 저장하고 관리하지 않음. API 서버는 들어오는 요청만을 단순히 처리하면 됨.
- 따라서 서비스의 자유도가 높고 구현이 단순해짐



#### 3) Cacheable (캐시 가능)

- HTTP 프로토콜 표준에서 사용하는 Last-Modified태그나 E-Tag를 이용하여 캐싱 구현 가능
- HTTP라는 기존 웹표준을 그대로 사용하기 때문에 웹의 기존 인프라 활용 가능한 것이 그 이유



#### 4) Self-descriptiveness (자체 표현 구조)

- REST API 메시지만 보고도 이를 쉽게 이해 할 수 있는 자체 표현 구조로 되어있음



#### 5) Client-Server 구조

- 서버는 API 제공, 클라이언트는 사용자 인증이나 컨텍스트(세션, 로그인 정보)등을 직접 관리
- 역할의 확실한 구분으로, 각자의 개발 내용이 명확해지고 의존성이 줄어듦



#### 6) 계층형 구조

- 서버를 다중 계층으로 구성 가능
- 구조상의 유연성(로드 밸런싱, 암호화 계층 추가)을 두거나, 네트워크 기반의 중간매체(PROXY, 게이트웨이)를 사용 가능



### 디자인 가이드

> **첫 번째,** URI는 정보의 자원을 표현해야 한다
> **두 번째,** 자원에 대한 행위는 HTTP Method(GET, POST, PUT, DELETE)로 표현한다



### HTTP 응답 상태 코드

> 잘 설계된 REST API는 URI만 잘 설계된 것이 아닌 그 리소스에 대한 응답을 잘 내어주는 것까지 포함함
>
> 정확한 응답의 상태코드만으로도 많은 정보를 전달할 수가 있기 때문에 응답의 상태코드 값을 명확히 돌려주는 것은 생각보다 중요한 일임