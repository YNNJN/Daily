## 2020. 2. 12 TIL



- D2 1974. 스도쿠 검증 문제



- 슬라이싱을 많이 쓰는 것이 실행 시간을 늘리는 것 같아서
  슬라이싱으로 풀었던 문제를 반복문을 이용해서 자르는 방법으로 다시 풂
-  두 개 이상의 반복문을 break 해야할 땐 flag 이용할 것



```python
def sudoku_tf(a):
    standard = set(range(1, 10))
    if a != standard:
        return 0
    return 1

t = int(input())
for tc in range(1, t+1):
    arr = [list(map(int, input().split())) for _ in range(9)]

    flag = 1
    if flag:
        for i in range(9):
            row = set()
            for j in range(9):
                row.add(arr[i][j])
            if sudoku_tf(row):
                pass
            else:
                flag = 0
    if flag:
        for j in range(9):
            col = set()
            for i in range(9):
                col.add(arr[i][j])
            if sudoku_tf(col):
                pass
            else:
                flag = 0
    if flag:
        for i in range(9):
            for j in range(9):
                square = set()
                for ii in range(3):
                    for jj in range(3):
                        square.add(arr[ii][jj])
                if sudoku_tf(square):
                    pass
                else:
                    flag = 0
    if flag:
        print('#{} {}'.format(tc, 1))
    else:
        print('#{} {}'.format(tc, 0))
```





- D2 1954. 달팽이 숫자



- 또한 델타를 이용한 방법으로 다시 풀 수 있었음



```python
t = int(input())
for tc in range(1, t+1):
    n = int(input())
    arr = [[0 for _ in range(n)] for _ in range(n)]

    d1 = [-1, 0, 1, 0]
    d2 = [0, 1, 0, -1]
    d = 0

    num = 1
    nr = nc = 0
    
    while num < n**2+1:
        arr[nr][nc] = num
        if nr + d1[d%4] == n or nr + d1[d%4] < 0 or nc + d2[d%4] == n or nc + d2[d%4] < 0:
            d += 1
        elif arr[nr+d1[d%4]][nc+d2[d%4]] != 0:
            d += 1
        nr += d1[d%4]
        nc += d2[d%4]
        num += 1

    print('#{0}'.format(tc))
    for ele in arr:
        print(' '.join(map(str, ele)))
```

