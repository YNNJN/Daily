## 2020. 2.17 TIL



- 배추 -> dfs가 몇 번 호출되었는지를 묻는 문제







### 중위 to 후위변환



- 컴퓨터를 위한 계산기
- 중위표기법 -> 후위표기법, 스택을 이용해 변환
  - 한 자 씩 읽어서 숫자면 그냥 출력
  - 연산자 우선순위에 따라 스택에 대한 연산 달라짐
    - 토큰이 연산자면 스택 top과 비교, 높으면 push, 여는 괄호면 push
    - 토큰이 닫는 괄호이면, 여는 괄호를 만날 때까지 모두 pop
    - 우선순위가 낮은 연산자를 만날 때까지 pop, 낮은 연산자일 경우push
    - 여는 괄호는 버리고, 스택이 비었으면 정상 종료
  - 괄호 또한, 스택 밖의 왼쪽 괄호는 우선순위가 가장 높고, 스택 안의 왼쪽 괄호는 우선순위가 가장 낮음
  - 중위표기법에 더 읽을 것이 없다면 중지, 있다면 1부터 다시 반복
  - 스택에 남아 있는 연산자를 모두 pop하여 출력







### 후위계산



```python
postfix = list(input())
stack = []
operator = ['+', '-', '*', '/']  # 연산자 리스트

for c in postfix:
    if c not in operator:  # 피연산자라면 스택에 넣기
        stack.append(int(c))
    else:
        op1 = stack.pop()
        op2 = stack.pop()
        if c == '+':
            stack.append(op2 + op1) #스택에서 처음 뽑은 것이 뒤로 감
        elif c == '*':
            stack.append(op2 * op1)
        elif c == '-':
            stack.append(op2 - op1)
        elif c == '/':
            stack.append(op2 / op1)
result = stack.pop()
print(result)
```







### 백트래킹



- 해를 찾는 도중에 막히면(해가 아니면) 되돌아가서 다시 해를 찾아가는 기법
- 최적화 문제(최대 최소값)와 결정 문제(Y/N) 해결 가능

- if문이 추가된 dfs
  - 해가 아니면 경로 탐색을 중지하여 시도의 횟수를 줄임 (Prunning 가지치기)
  - dfs와 시간복잡도에 차이가 있는 것은 아님(최악의 경우 exponential time인 것은 동일)



- 방법
  - 상태 공간 트리(해를 찾기 위한 과정을 트리로 표현)의 dfs 실시
  - 각 노드가 유망한지를 점검
  - 그 노드가 유망하지 않다면, 그 노드의 부모 노드로 되돌아가 검색을 계속함



- 미로찾기 문제도 스택에 방향을 저장하고, 막힌 경우 다시 이전의 노드로 돌아오는 방법으로 풀이 가능
- (이전에 풀었던 visited 방식 아닌)





- 완전탐색 이용한 부분집합의 합

```python
#원소의 합이 10인 부분집합의 개수 출력
#완전탐색
def f(i,n,k): #i번째 원소를 포함하는 경우/포함하지 않는 경우->재귀호출
    global bit
    global cnt
    if i == n: #base case: bit의 모든 칸이 결정됨
        #print(bit) #모든 경우의 수
        s = 0
        for j in range(n):
            if bit[j] == 1:
                s += j+1
        if s == k:
            cnt += 1
        return
    else:
        bit[i] = 1 #i번째 원소가 선택된 경우
        f(i+1,n,k)
        bit[i] = 0 #선택되지 않은 경우
        f(i+1,n,k)

n = 10 #원소의 수
k = 10 #부분집합의 합
bit = [0] * n #원소의 포함여부 저장
cnt = 0 #조건 만족하는 부분집합 개수
f(0,n,k) #부분집합을 구하고 -> 총합이 10인 부분집합 개수 세기
print(cnt)
```





- 백트래킹 이용한 부분집합의 합

```python
def f(i,n,k,s,r): #s:선택된 원소들의 합, r: 남은 원소들의 합(선택 가능한 후보 중)
    global cnt

    # base case:
    if s == k: #나머지 원소 하나라도 더 선택하면 k보다 커지니, 더 탐색할 이유x
        cnt += 1
        return
    elif i == n: #모든 원소를 고려했는데, 합이 k가 되는 경우가 없음
        return
    elif s > k: #현재까지의 누적합이 k보다 크면 더 탐색할 이유x
        return
    elif s + r < k: #현재까지의 합 + 후보군의 합이 k보다 작다면 정답이 될 가능성x
        return #back tracking, 가지치기
    else:
        # i번째 요소가 선택된 경우
        f(i+1, n, k, s+i+1, r-(i+1))
        # i번째 요소가 선택되지 않은 경우
        f(i+1, n, k, s, r-(i+1))

n = 20 #1부터 n까지가 집합의 원소
k = 10 #부분집합의 합
cnt = 0

f(0,n,k,0,(1+n)*n//2) #원소의 위치(i), 부분집합의 합, 선택 후보들의 합
print(cnt)
```







### n-queen

- n*n 체스판에  n개의 queen을 서로 위협하지 않도록 배치하는 문제
- 같은 행, 같은 열, 같은 대각선 공격







### Divide and Conquer

- 분할(Divide):  해결할 문제를 여러 개의 작은 부분으로 나눔
- 정복(Conquer): 나눈 작은 문제를 각각 해결함
- 통합(Combine): (필요하다면) 해결된 해답을 모음



```python
#분할정복
'''
홀/짝 경우 나눠 생각
c^8 = c^4 * c^4
c^9 = c^4 * c^4 * c
'''

def power2(base,exponent):
    if exponent == 0 or base == 0:
        return 1
    if exponent % 2 == 0:
        newbase = power2(base, exponent/2)
        return newbase * newbase
    else:
        newbase = power2(base, (exponent-1)/2)
        return newbase * newbase * base
print(power2(2,10))
```







### 퀵 정렬



- 주어진 배열을 두 개로 분할하고, 각각을 정렬함
- partitioning, 점점 쪼개가며 정렬하는 방식
- pivot, 기준점을 중심으로 작은 것은 왼 편, 큰 것은 오른편에 위치시킴
- 각 부분 정렬이 끝난 후, 합병정렬은 '합병'이란 후처리 작업이 필요하나, 퀵정렬은 필요x



```python
#중간값을 기준으로 양 옆을 다시 퀵솔팅함 (재귀)
#피봇의 설정 위치는 달라질 수 있음
```



```python
def partition(arr,low,high):
    pivot = (low+high)//2
    l = low #l,r의 초기값 설정
    r = high
    while l < r:
        while arr[l] < arr[pivot] and l < r: #l의 값이 pivot보다 작을 때까지
            l += 1 #오른쪽으로 이동
        while arr[r] >= arr[pivot] and l < r: #r의 값이 pivot보다 크거나 같을 때까지
            r -= 1 #왼쪽으로 이동
        if l < r:
            if l == pivot:
                pivot = r
            arr[l], arr[r] = arr[r], arr[l]
    arr[pivot], arr[r] = arr[r], arr[pivot]
    return r

def quicksort(arr, low, high):
    if low < high:
        p = partition(arr,low,high)

        quicksort(arr,low,p-1)
        quicksort(arr,p+1,high)

arr = [10, 7, 8, 9, 1, 5]
n = len(arr)
quicksort(arr, 0, n-1)
print(arr)
```

