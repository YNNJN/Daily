## 2020. 2. 6 TIL

- D2 2005. 파스칼의 삼각형 - 2차원 배열 풀이 - 가장 처음 열을 안 쓰지만 만들어둠



```python
t = int(input())
for tc in range(1, t+1):
    n = int(input())
    arr = [[0 for _ in range(n+1)] for _ in range(n)]
    arr[0][1] = 1 #첫째줄은 1로 초기화
    for i in range(1, n):
        for j in range(1,i+2):
            arr[i][j] = arr[i-1][j-1] + arr[i-1][j]

    print('#{}'.format(tc))
    for i in range(len(arr)):
        for j in range(len(arr[i])):
            if arr[i][j]: #결과가 0이 아닐 때
                print(arr[i][j], end=' ')
        print()
```







- D2 2001. 파리퇴치



```python
t = int(input())
for tc in range(1, t+1):
    n, m = [list(map(int, input().split()))]
    arr = [list(map(int, input().split())) for _ in range(n)]

    max_V = 0
    for i in range(n-m+1):
        for j in range(n-m+1):
            for ii in range(m):
                for jj in range(m):
                    print(arr[i+ii][j+jj], end=' ')

        if maxV < sum:
            maxV = sum

    print('#{} {}',format(tc, maxV))
```







- D3 4615. 오셀로 게임



사방만 확인하는 것이 아닌, 대각까지 모든 방향을 확인해서 돌의 색을 바꿀 수 있는지 확인해야

대각선 방향 확인

탐색을 하면서 조건을 검색하고 조건이 아니면 뺏다가~



```python
def check(x, y, color):
    colors = [2, 1]
    dx = [-1, -1, -1, 0, 0, 1, 1, 1]
    dy = [-1, 0, 1, -1, 1, -1, 0, 1]

    for i in range(8):
        tx = x + dx[i]
        ty = y + dy[i]
        flag = False
        if tx < 0 or ty < 0 or tx > n - 1 or ty > n - 1:
            pass
        elif board[ty][tx] == colors[color-1]:  #계속 다른 색의 돌을 만나는 조건에서 그 방향으로 계속 진행
            cnt = 0
            while cnt < n:
                cnt += 1
                tx += dx[i]
                ty += dy[i]
                if tx < 0 or ty < 0 or tx > n - 1 or ty > n - 1:
                    pass
                elif board[ty][tx] == color: #같은 색 돌 만남
                    flag = True
                elif board[ty][tx] == 0: #중간에 빈 칸이 있다면 색칠x
                    break

            if flag:  #색을 바꿀 때
                tx = x + dx[i]
                ty = y + dy[i]
                for j in range(cnt):
                    board[ty][tx] = color
                    tx += dx[i]
                    ty += dy[i]


for case in range(1, int(input()) + 1): #초기 조건 세팅
    n, m = map(int, input().split())
    board = [[0 for _ in range(n)] for _ in range(n)]
    board[n//2 - 1][n//2], board[n//2][n//2 - 1] = 1, 1  #흑돌
    board[n//2 - 1][n//2 - 1], board[n//2][n//2] = 2, 2  #백돌

    for i in range(m): #함수 호출
        x, y, color = map(int, input().split())
        board[y-1][x-1] = color
        check(x-1, y-1, color)

    white = black = 0 #색깔 카운팅
    for i in board:
        for j in i:
            if j == 1:
                black += 1
            elif j == 2:
                white += 1
    print("#{} {} {}".format(case, black, white))
```







- D3 5356. 의석이의 세로로 말해요



```python
t = int(input())
for tc in range(1, t+1):
    words = [list(input()) for _ in range(5)]
    col_words = []

    for j in range(15):
        for i in range(5):
            if len(words[i]) > j: #len은 언제나 index보다 1크기 때문에, 이 때의 값만 col_words에 더함
                col_words.append(words[i][j])

    print('#{0} {1}'.format(tc, ''.join(map(str, col_words))))
```







- D4 1211. ladder2



현재 위치에서 갈 수 있는 선택지는 왼, 오, 아래

왼, 오가 선택되면 아래는 생각 안해도 됨

지나온 길의 조건은 제해줘야됨 (사방탐색, 와일문 돌릴 때 유의할 점)



```python
def search(r, c, arr):
    dr = [0, 0, 1]
    dc = [1, -1, 0]
    direc = ["l","r","d"]
    cnt = 1
    now_r, now_c = r, c
    visited = [] # 지나온 (r,c) 저장
    while now_r < 99:
        for i in range(3):  #새로운 좌표를 계산함
            tr = now_r + dr[i]
            tc = now_c + dc[i]

            if tr < 0 or tc < 0 or tr > n-1 or tc > n-1:  #범위 안인지
                pass
            elif arr[tr][tc] == 0:  #사다리 위인지
                pass
            elif (tr,tc) in visited :  #이미 지나온 곳인지
                pass

            else: #갈 수 있다면
                visited.append( (tr,tc) )
                cnt += 1
                now_r = tr
                now_c = tc
                #print(direc[i],now_r,now_c, cnt)
                break
    return cnt

for tc in range(1, 11):
    t = int(input())
    n = 100
    arr = [list(map(int, input().split())) for _ in range(n)]
    ans = 100 * 100  #최대값으로 미리 설정
    minIdx = 0

    for j in range(n):
        if arr[0][j] == 1:  #i는 시작점
            cnt = search(0, j, arr)
            if ans > cnt:
                ans = cnt
                minIdx = j

    print('#{} {}'.format(tc, minIdx))
```

