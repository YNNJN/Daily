- 그래프를 탐색하는 방법

  - **BFS(Breadth First Search)**

    - 탐색 시작점의 인접한 정점들을 모두 차례로 방문한 후, 방문했던 정점을 시작점으로 하여 다시 인접한 정점들을 차례로 방문하는 방식
    - 인접한 정점들에 대해 탐색을 한 후 차례로 다시 탐색을 진행해야 하므로, 선입선출 형태의 자료구조인 `queue`를 활용함
    - 인접 정점을 정하는 순서? 거리(edge의 개수) 순서로 탐색
      - 거리가 n인 것을 찾는 방법? 거리가 n-1인 것들의 인접
      - 줄을 세워가면서 처리할 순서를 정해줌
    - **DFS vs BFS**
      - dfs가 그래프 안에서 돌아다니는 꼴이라면, bfs는 한 층씩 훑으며 거리에 따라서 건너 뛰는 모양
      - 탐색 규칙이 완전히 다름

    

    - 입력 parameter: `그래프 G`와 `탐색 시작점 v`

    - 1. 초기화작업 - 2. 반복 부분 - 3. 모든 노드 i에 대해 t에 인접이고, 방문하지 않았다면

    - ```
      def BFS(G,v):
      
      	#초기화 작업
      	visited = [0]*(n+1)
      	queue = [] #줄을 선 순서대로 꺼내기 때문에 큐를 이용
      	queue.append(v) #시작점 v를 큐에 삽입
      	visited[v] = True
      	
      	#반복 부분
      	while queue: #처리할 노드들이 있는 동안 반복
      		t = queue.pop(0) #deq
      		visited(t) #t 노드에 대해 할 일
      		
      		
      		#모든 노드 i에 대해 t에 인접이고, 방문하지 않았다면
      		for i in G[t]:
      			if not visited[i]:
      				queue.append(i) #enq
      				visited[i] = True
      
      
      #DFS의 재귀 구현과 비슷한 꼴
      ```

    - 그래프의 중복이 없다면 -> 노드의 개수만큼만 queue를 만듦

    - 실제 노드 번호를 인덱스 번호와 일치시키는 것 권장

  

  - DFS(Depth First Search)
    - 재귀
    - 반복
      - 스택으로 구현 
    - 탐색 순서를 정하는 규칙도 다양



- 인접리스트

  - 그래프의 연결 관계를 배열로 나타내는 방식

    ```
    adj[i] : 노드 i에 연결된 노드들을 원소로 갖는 vector #저장된 노드의 순서는 의미 x
    ```

  - 간선의 개수에 비례하는 메모리만 차지 (연결된 노드에 대한 정보만 저장하기 때문)

  - 간선의 개수인 O(E)의 시간 복잡도를 가짐

  - 하지만 노드 i가 노드 j와 연결되어있는지 알기 위해 adj[i] 벡터 전체를 돌며 j를 성분으로 갖는지 확인해야 (시간복잡도 O(V), 인접 행렬은 O(1))

- 인접 행렬

  - 그래프의 연결 관계를 이차원 배열로 나타내는 방식

    ```
    adj[i][j] : 노드 i에서 j로 가는 간선이 있으면 1, 아니면 0
    ```

  - 방향이 없는 그래프의 경우, 대각성분을 기준으로 대칭인 성질을 가짐

  - 구현이 쉽지만 O(V)의 시간 복잡도를 가짐



- 노드 뿐 아니라 정점의 개수, 마지막 정점 번호도 추가로 알아야 하는 문제 다수
- 큐의 어떤 노드가 어떤 노드에 의해서 visitied가 된 건지 따지기
- 몇 개의 엣지를 거쳐야 **최단거리**에 도달할 수 있는지? (거리 정보 함께 남겨두기)
  - visited[i] = True
  - visited[i] = visited[t] + 1
  - True가 아니어도, visited 하면서 += 1