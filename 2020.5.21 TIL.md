## Graph

<br>

#### 그래프 개념

- 구성요소
  - 정점(Vertex)
  - 간선(Edge)
- |v|: 정점의 개수, |e|: 그래프에 포함된 간선의 개수
  - |v| 개의 정점을 갖는 그래프는 최대 |v| (|v|-1) /2 간선이 가능함
    - ex. 5개 정점 => 간선이 10개까지 가능
- 그래프는 선형 자료구조나 트리 자료구조로 표현하기 어려운 N:N 관계를 가지는 원소들을 표현함

<br>

#### 그래프 유형

- 무향그래프 (Undirected Graph)
- 유향그래프 (Directed Graph)
- 가중치그래프 (Weighted Graph)
- 사이클이 없는 방향그래프 (**`DAG`**: Directed Acyclic Graph)
  - `사이클` - 시작 정점과 끝 정점이 같은 경로
    - ex. 과정 이수에서 '선수과목' 개념
  - `단순 경로` - 경로 중 한 정점을 최대 한 번만 지나는 경로



<br>

<br>

## 그래프 표현

- 간선의 정보를 저장하는 방식을 말함
- 메모리나 성능을 고려해서 결정함

<br>

#### 인접(Adjacency)

- 두 개의 정점에 간선이 존재하면, 서로 인접해있다고 함
- 완전그래프에 속한 임의의 두 정점들은 모두 인접해있음

<br>

#### 인접행렬 (Adjacent matrix)

> 두 정점을 연결하는 간선의 유무를 행렬로 표현함

- |v| x |v| 크기의 2차원 배열을 이용해서 간선 정보를 저장함
- 행 번호와 열 번호는 그래프의 정점에 대응함
- 두 정점이 인접하면 1, 그렇지 않으면 0으로 표현
- 무향그래프
  - i 번째 행의 합 = i 번째 열의 합 = Vi의 차수

- 유향그래프
  - 행 i의 합 = Vi의 진출 차수
  - 열 i의 합 = Vi의 진입 차수
- 단점
  - 희소그래프에서도 V*V 크기를 공간을 확보해야 함
  - 인접 정점을 찾을 때의 연산 또한 V번이 필요

<br>

#### 인접리스트(Adjacent List)

> 각 정점에 대한 인접 정점들을 순찾거으로 표현함
>
> 하나의 정점에 대한 인접 정점들을, 각각을 노드로 하는 연결리스트로 저장함



<br>

<br>

## 그래프 순회

> 비선형구조인 그래프로 구현된 모든 자료(정점)를 빠짐없이 탐색함

- 방법
  - **DFS (깊이우선)**
    - 가장 마지막에 만났던 갈림길의 정점으로 돌아가서 다시 DFS를 반복해야 하므로
    - 후입선출(LIFO) 구조의 `stack`을 활용함
  - **BFS (너비우선)**
    - 인접한 정점들에 대해 탐색한 후 차례로 다시 BFS를 진행해야 하므로
    - 선입선출(FIFO) 구조의 `queue`를 활용함



<br>

<br>

## 상호배타 / 서로소 집합 (Disjoint-sets)

> 서로 중복하여 포함된 원소가 없는 집합을 말함 (자료구조)
>
> 즉 교집합이 없는 집합을 말함

- 구분
  - 집합에 속한 하나의 특정 멤버를 통해 구분함
  - 그 특정 멤버를 대표자(representative)라고 함
- 표현
  - **`연결리스트`**
    - 같은 집합의 원소들은 하나의 연결리스트로 관리함
    - 연결리스트의 맨 앞의 원소를 집합의 대표 원소로 삼음
    - 각 원소는 집합의 대표 원소를 가리키는 링크를 가짐
  - **`트리`**
    - 하나의 집합을 하나의 트리로 표현함
    - 자식노드가 부모노드를 가리키며, `root node`가 대표자가 됨
- 연산
  - `Make-set(x)`
    - 초기화
    - 원소 x를 유일한 원소로 하는 집합을 생성함
  - `Union(x,y)`
    - 합하기
    - x가 포함된 집합과 y가 포함된 집합을 합쳐줌
  - `Find-set(x)`
    - 찾기
    - x가 포함된 집합의 대표자를 리턴함



<br>

<br>

## Union find

> 상호배타 집합을 표현할 때 사용하는 알고리즘
>
> 집합 구현에는 비트 벡터, 배열, 연결리스트를 이용할 수 있으나, 가장 효율적인 트리구조를 활용하여 구현함

<br>

#### Union find 알고리즘을 트리 구조로 구현하는 이유

1. `배열`의 경우

- Array[i] : i 번 원소가 속하는 집합의 번호 (집합번호 = 루트 노드의 번호)
- Make-set(x) : Array[i]와 같이 각자 다른 집합 번호로 초기화함
- Union(x,y) : 배열의 모든 원소를 순회하면서 y의 집합 번호를 x의 집합 번호로 변경함 `(O(N))`
- find(x) : 한 번에 x가 속한 집합 번호를 찾음 (O(1))

<br>

2. `트리`의 경우

- 같은 집합 = 하나의 트리 (집합번호 = 루트노드)
- Make-set(x) : 각 노드는 모든 루트노드이므로, N개의 루트 노드를 생성하고 자기 자신으로 초기화함
- Union(x,y) : x,y의 루트노드를 찾고, 다르면 y를 x의 자손으로 넣어 두 트리를 합함
  - `(O(N)보다 작음)` -> **find 연산이 전체 수행시간을 지배함**
- find(x) : 노드의 집합번호는 루트노드이므로, 루트 노드를 확인하여 같은 집합인지 확인함
  - 트리의 높이와 시간복잡도가 동일함 `(최악: O(N-1))`

<br>

```python
'''
서로소 집합
N = 6
union(1,3)
union(2,3)
union(5,6)
print(p)
print(find_set(6))

output:
[0, 2, 2, 1, 4, 5, 5]
5

'''

def make_set(x):
    p[x] = x
    
def find_set(x):
    if p[x] == x:
        return x
    else:
        return find_set(p[x])
      
def union(x,y):
    # x의 대표자, y의 대표자를 찾음
    p[find_set(y)] = find_set(x)
    
n = 6
p = [0] * (n+1)

for i in range(1, n+1):
    make_set(i)

    
union(1,3)
union(2,3)
union(5,6)
print(p)
print(find_set(6))

      
'''
문제점 - 대표자를 찾기 위해 재귀호출을 여러번 실행함
    => 대표자를 바로 찾아가도록 건너 띄어가야
    p[b] <- f


'''
```

<br>

#### 사용예

- 전체 집합이 있을 때 구성 원소들이 겹치지 않도록 분할하는 데 자주 사용됨
  - Kruskal MST 알고리즘에서 새로 추가할 간선의 양 끝 정점이 같은 집합에 속해있는지(사이클 형성 여부 확인)에 대해 검사하는 경우
  - 합집합 연산, 두 원소가 같은 집합에 포함되어있는지를 확인하는 연산을 수행하려는 경우
  - 친구 네트워크에 몇 명이 있는지를 구하는 프로그램을 작성하는 경우

<br>

<br>

### +

### 연산 효율 높이기

1. `Rank를 이용한 Union`
   - rank에 트리의 높이를 저장함
   - 항상 높이가 더 낮은 트리를 높은 트리 밑에 넣음
2. `Path Compression`
   - 시간 복잡도 O(logN)
   - Find-set을 행하는 과정에서 만나는 모든 node들이 직접 root를 가리키도록 포인터를 바꿔줌

