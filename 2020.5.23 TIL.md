# 최단경로

<br>

### 정의

- 간선의 가중치가 있는 그래프에서 두 정점 사이의 경로들 중 간선의 가중치 합이 최소인 경로
  - 간선의 가중치가 균일할 때는 BFS

<br>

### 한 점 - 다수의 점

- 하나의 시작 정점에서 끝 정점까지의 최단 경로
  - **`다익스트라(Dijkstra)`** 알고리즘
    - 음의 가중치를 허용하지 않음
  - **`벨만포드(Bellman-Ford)`** 알고리즘
    - 음의 가중치를 허용함
    - 음수 사이클 x

<br>

### 모든 점 - 모든 점

- 모든 정점들에 대한 최단 경로
  - **`플로이드-워샬(Floyd-warchall)`** 알고리즘



<br>

<br>

## Dijkstra Algorithm

> 시작 정점에서 거리가 최소인 정점을 선택해나가면서 최단 경로를 구하는 방식

- 시작 정점(s)에서 끝 정점(t) 까지의 최단 경로에 정점 x가 존재함
- 이 때 최단 경로는 s에서 x까지의 최단 경로와 x에서 t까지의 최단 경로로 구성됨
- 탐욕 (greedy) 기법을 사용한 알고리즘으로, MST의 `Prim Algorithm`과 유사함

<br>

#### 동작

1. 현재 선택한 정점(처음엔 시작점)에 곧장 연결되고, 아직 방문하지 않은 정점들을 모두 봄
2. 선택한 정점과 보고있는 정점 사이의 거리와 시작 정점과 선택한 정점까지의 최단거리의 합이 현재까지 구한 시작 정점과 보고 있는 정점 사이의 거리보다 짧을 경우, 이를 갱신해줌
3. 1,2번 수행이 모두 끝난 후 아직 방문하지 않은 정점들 중 시작점과의 거리가 가장 짧은 정점을 선택함
4. 방문하지 않은 정점이 존재하여 정점을 선택했다면, 현재 구한 시작점으로부터의 현재 선택한 정점 사이의 거리는 최단거리임
5. 방문하지 않은 정점이 존재하지 않는다면 수행을 종료함. 그렇지 않다면 1번으로 돌아가 수행을 반복함

<br>

#### 증명

1. 시작점은 시작점으로부터의 최단거리임이 보장됨 (거리 0)
2. 시작점으로부터 어떠한 정점으로의 최단경로가 존재한다면, 그 경로의 끝 정점의 이전 단계에 있는 정점과 시작점 사이의 경로도 최단경로임
   - 만약 그 경로가 최단경로가 아니라면, 끝 정점과 이전 단계 정점을 잇는 간선의 거리와 이전 단계 정점의 최단 경로를 합한 현재 경로가 현재의 경로의 거리보다 더 짧으므로 시작점으로부터 끝 정점까지의 경로가 최단경로라는 가정에 모순
3. 2의 귀류 증명에 의거하여, 현재까지 알아낸 최단 경로를 찾은 정점들로부터 바로 이어진 다른 정점으로의 간선을 이은 경로들 중에는 반드시 최단경로임이 보장되는 정점이 하나 이상 있음 
4. 3에 의해 현재까지 최단경로를 찾은 정점들로부터 바로 이어진 다른 정점으로의 간선을 이은 경로들을 찾은 후, 아직 최단 경로를 찾지 못한 정점들 중에서 시작점과의 거리가 가장 작은 정점이 최단경로임

<br>

#### 음수 간선이 안되는 이유

- 그래프 내에 음수 사이클이 있을 경우, 다익스트라가 동작하면서 무한히 음수 사이클을 돌면서 거리가 작아질 수 있음
- 다익스트라에서는 같은 간선을 재이용하는 것을 고려하지 않기 때문에, 이 상황에서 최단 경로를 구할 수 없음

<br>

```python
'''
(인접리스트 이용한 구현)

6 11
0 1 3
0 2 5
1 2 2
1 3 6
2 1 1
2 3 4
2 4 6
3 4 2
3 5 3
4 0 3
4 5 6

output:
[0, 3, 5, 9, 11, 12]

'''

# dist, selected 배열 준비
# 시작점 선택
# 모든 정점이 선택될 때 까지
# 아직 선택되지 않고 dist의 값이 최소인 정점 : u
# 정점 u의 최단거리 결정
# 정점 u에 인접한 정점에 대해서 간선 완화

V, E = map(int, input().split())
adj = {i:[] for i in range(V)}

for i in range(E):
    s, e, c = map(int, input().split())
    adj[s].append([e,c]) # 방향 그래프

INF = float('inf')
dist = [INF]*V
selected = [False]*V

dist[0] = 0
cnt = 0
while cnt <V:
    # dist가 최소인 정점 찾기
    MIN = INF
    for i in range(V):
        if not selected[i] and dist[i] < MIN:
            MIN = dist[i]
            u = i
    # 결정
    selected[u] = True
    cnt += 1

    # 간선 완화
    for w, cost in adj[u]: # 도착 정점, 가증치
        if dist[w] > dist[u] + cost:
            dist[w] = dist[u] + cost
    
print(dist) # [0, 3, 5, 9, 11, 12]


```

