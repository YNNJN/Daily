# DB 설계

> 요구조건 분석 -> 설계(개념적-> 논리적 -> 물리적 설계) -> 구현 -> 운영 및 유지보수

- 개념적 설계	
  - ERD
- 논리적 설계
  - 스키마 정의
    - **개념 스키마** - 논리적 관점(사용자 관점)에서 본 데이터의 논리적 구조
      - 스키마, 뷰
      - DB 전체를 기술한 것이므로, 한 데이터베이스 시스템에서 유일함
    - **외부 스키마** - 사용자가 바라보는 일부분에서의 논리적 구조 (서브스키마)
    - **내부스키마** - 물리적 저장장치 관점에서 본 DB의 구조
  - 목표 DBMS에 따라 관계형, 계층형, 망형 모델
  - 이 단계에서 정규화 또한 진행됨

- 물리적 설계
  - 하드웨어, OS 특성 고려하여 알맞은 인덱스 구조, 내부저장 구조, 접근 경로 설계



<br><br>

# Relation

> 데이터를 원자 값으로 갖는 이차원의 테이블

- Column = Attribute
- Row = Tuple
- Domain
  - 하나의 Attribute가 취할 수 있는 같은 타입의 원자 값들의 집합

<br>

<br>

# Transaction

> 데이터베이스에서 하나의 논리적 기능을 수행하기 위한 일련의 연산 집합
>
> 작업의 단위임

- Commit
  - 트랜잭션 처리가 정상적으로 종료되어 트랜잭션이 수행한 변경 내용을 DB에 반영하는 연산
- RollBack
  - 트랜잭션 처리가 비정상으로 종료되어 DB의 일관성이 깨졌을 때
  - 트랜잭션이 행한 모든 변경 작업을 취소하고 이전 상태로 되돌리는 연산
- 데이터베이스 트랜잭션이 안전하게 수행됨을 보장하는 특성 (`ACID`)
  - 원자성 - 트랜잭션의 연산은 DB에 All or Nothing 반영되어야
  - 일관성 - 트랜잭션 수행이 성공적으로 완료되면 언제나 일관성 있는 DB 상태를 유지해야 
  - 독립성 - 한 트랜잭션이 작업이 완료되기 전에는 작업중인 데이터를 다른 트랜잭션들이 접근 x 하도록 해야
  - 영속성 - 트랜잭션의 실행이 성공적으로 완료된 후에는 시스템에 오류가 발생하더라도 변경된 내용은 계속 보존되어야

<br>

### Locking

> 트랜잭션이 DB를 다루는 동안 다른 트랜잭션이 관여하지 못하게 함

- 무조건적인 Locking으로 동시에 수행되는 트랜직션들을 일렬로 대기시킨다면 DB의 성능은 떨어짐
- 반대로 응답성을 높이기 위해 Locking의 범위를 줄인다면 잘못된 값이 처리될 위험이 있음
- 최대한 효율적인 Locking 방법 => `Isolation Level`



<br>

<br>

# Join

- 2개의 테이블에 대해 연관된 튜플들을 결합하여 새로운 릴레이션을 반환함

<br>

## Inner Join

### Equi Join

> Join 대상 테이블에서 공통 속성을 기준으로 `=` 비교에 의해 같은 값을 가지는 행을 연결하여 결과를 생성함

- 한 테이블에만 있는 속성은 테이블명을 생략 가능

- 두 테이블 모두 속해 있는 속성은 반드시 속성명을 테이블명과 함께 표시해야

- **`Natural Join`**

  - 중복된 속성을 제거하여 1번만 표기하는 방법
  - 조인할 속성을 지정하지 않기 때문에 조인하려는 두 테이블에는 같은 이름, 같은 속성의 도메인이 존재해야

- 표기 형식

  - Where 절을 이용

  ```sql
  SELECT [테이블명1.]속성명, [테이블명2.]속성명
  FROM 테이블명1, 테이블명2
  WHERE 테이블명1.속성명 = 테이블명2.속성명;
  ```

  - Natural Join을 이용

  ```sql
  SELECT [테이블명1.]속성명, [테이블명2.]속성명
  FROM 테이블명1 Natural Join 테이블명2;
  ```

  - Join ~ Using 절을 이용

  ```sql
  SELECT [테이블명1.]속성명, [테이블명2.]속성명
  FROM 테이블명1 Join 테이블명2 USING(속성명);
  ```

<br>

### Non-Equi Join

> `=` 조건이 아닌 나머지 비교 연산자를 사용하는 Join 방법

```sql
SELECT [테이블명1.]속성명, [테이블명2.]속성명
FROM 테이블명1, 테이블명2
WHERE (Non-Equi Join 조건);
```

<br>

## Outer Join

> Join 조건에 만족하지 않는 튜플도 결과로 출력하기 위한 방법

- Inner Join은 두 릴레이션에서 관련있는 튜플만 표시됨
- Left Outer Join
  - 좌측 릴레이션이 기준이되어 좌측 릴레이션의 튜플은 모두 표시
  - 우측 릴레이션에서는 관련 있는 튜플만 표시
- Right Outer Join
  - 우측 릴레이션이 기준이되어 좌측 릴레이션의 튜플은 모두 표시
  - 좌측 릴레이션에서는 관련 있는 튜플만 표시

- Outer Join에서 `+` 를 사용하면 Inner Join과 동일한 형식으로 사용 가능
- Left일 때는 조건문의 우측에, Right일 때는 조건문의 좌측에 `+` 를 사용함

<br>

### Left Outer Join

> Inner Join의 결과를 구한 후, **우측** 릴레이션의 어떤 튜플과도 맞지 않는
>
> **좌측** 릴레이션에 있는 튜플들에 NULL 값을 붙여 Inner Join 결과에 추가함

```sql
SELECT [테이블명1.]속성명, [테이블명2.]속성명
FROM 테이블명1 Left Outer Join 테이블명2
ON 테이블명1.속성명 = 테이블명2.속성명;

SELECT [테이블명1.]속성명, [테이블명2.]속성명
FROM 테이블명1, 테이블명2
ON 테이블명1.속성명 = 테이블명2.속성명(+);
```

<br>

### Right Outer Join

> Inner Join의 결과를 구한 후, **좌측** 릴레이션의 어떤 튜플과도 맞지 않는
>
> **우측** 릴레이션에 있는 튜플들에 NULL 값을 붙여 Inner Join 결과에 추가함

```sql
SELECT [테이블명1.]속성명, [테이블명2.]속성명
FROM 테이블명1 Right Outer Join 테이블명2
ON 테이블명1.속성명 = 테이블명2.속성명;

SELECT [테이블명1.]속성명, [테이블명2.]속성명
FROM 테이블명1, 테이블명2
ON 테이블명1.속성명(+) = 테이블명2.속성명;
```

<br>

### Full Outer Join

> Left Outer Join + Right Outer Join

```sql
SELECT [테이블명1.]속성명, [테이블명2.]속성명
FROM 테이블명1 Full Outer Join 테이블명2
ON 테이블명1.속성명 = 테이블명2.속성명;
```



<br>

<br>

# 이상 현상 (Anomaly)

> 테이블에서 일부 속성들의 종속으로 인해 데이터의 중복이 발생하고,
>
> 이 중복으로 인해 테이블 조작 시 문제가 생기는 현상

- 종류
  - 삽입 이상 (Insertion Anomaly)
    - 테이블에 데이터를 삽입할 때 의도와는 상관없이 원하지 않은 값들로 인해 삽입할 수 없게 되는 현상
  - 삭제 이상 (Deletion Anomaly)
    - 테이블에서 한 튜플을 삭제할 때 의도와는 상관없는 값들도 함께 삭제되는 현상
  - 갱신 이상 (Update Anomaly)
    - 테이블에서 튜플에 있는 속성 값을 갱신 시 일부 튜플의 정보만 갱신되어 정보에 불일치성(Inconsistency)이 생기는 현상



<br>

<br>

# 함수적 종속

### 완전 함수적 종속

> 어떤 속성이 기본키에 대해 완전히 종속

### 부분 함수적 종속

> 기본키가 2개 이상 구성된 합성키이고
>
> 합성키를 구성하는 하나의 속성에 함수적 종속성을 가질 때 부분 함수적으로 종속

```
수강 테이블은 (학번, 과목번호)가 기본키
성적은 학번과 과목번호가 같을 경우에는 항상 같은 성적
즉 성적은 학번과 과목번호에 의해서만 결정되기 때문에 성적은 기본키(학번, 과목번호)에 완전 함수적 종속

반면 학년은 과목번호에 관계없이 학번이 같으면 항상 같은 학년이므로
즉 기본키의 일부인 학번에 의해서 학년이 결정되기 때문에 학년은 기본키(학번, 과목번호)에 부분 함수적 종속
```



<br>

<br>

# 정규화 (Normalization)

> 상호종속적인 관계를 갖는 특성을 이용하여 무손실 분해하는 과정
>
> 최종목적은 이상현상 발생 가능성을 줄이는 것

- 데이터 중복성을 제거하기 때문에 (쪼개주기 때문에) 성능 자체는 향상됨
- 그러나 그만큼 조인이 많이 발생하기 때문에 성능 저하가 나타날 수 있음
- 무분별한 반정규화는 데이터 무결성을 깨뜨릴 수 있음
- 성능의 이슈와 데이터 무결성의 보존 사이에서 정규화와 반정규화를 고려하게 됨

<br>

### 제 1 정규형

> 모든 속성의 도메인이 원자 값(Atomic Value)만으로 되어있는 정규형

- 테이블에서 기본키의 일부에 함수적 종속되는 부분 함수적 종속을 제거하기 위해
- 속성들을 분리하여 제 2정규형을 만듦

### 제 2 정규형

> 테이블 R이 제 1 정규형이고
>
> 기본키가 아닌 모든 속성이 기본키에 대해 **완전 함수적 종속**을 만족하는 정규형

### 제 3 정규형

> 테이블 R이 제 2 정규형이고
>
> 기본키가 아닌 모든 속성이 기본키에 대해 **이행적 함수적 종속**을 만족하지 않는 정규형

### BCNF

> 테이블 R에서 **모든 결정자(X -> Y에서 Y)가 후보키(Candidate Key**)인 정규형
>
> 일반적으로 제 3 정규형에 후보키가 여러 개 존재하고 이러한 후보키들이 서로 중첩되어 나타나는 경우에 적용 가능

### 제 4 정규형

> 테이블 R에 다중갑 종속 A ->-> B가 존재하는 경우
>
> **R의 모든 속성이 A에 함수적 종속 관계**를 만족하는 정규형

### 제 5 정규형

> 테이블 R의 모든 **조인 종속**이
>
> **R의 후보키를 통해서만 성립**되는 정규형



<br>

<br>

# 반정규화

- 반정규화를 언제 진행?
  - 자주 사용되는 테이블에 접근하는 프로세스의 수가 많고 항상 일정한 범위만을 조회하는 경우
  - 테이블에 대량의 데이터가 있고 대량의 데이터 범위를 자주 처리하는 경우, 처리 범위를 줄이지 않으면 성능을 보장 할 수 없을 경우
  - 테이블에 지나친 조인이 걸려있을 경우
- 반정규화를 언제 진행하지 않아도?
  - 인덱스나 클러스터링을 통해 성능 향상을 유도할 수 있는 경우
  - 파티셔닝 기법을 통해 성능을 향상시킬 수 있는 경우



<br>

<br>

# 데이터베이스와 성능

<br>

## 대량 데이터와 성능

- 칼럼의 수가 많은 경우 트랜잭션 특성에 따라 테이블을 1:1 형태로 분리할 수 있는지 검증함
- 칼럼 수가 적지만 데이터 용량이 많아 성능저하가 예상된다면, 테이블에 대해 파티셔닝 전략을 도모함

<br>

### 절차

1. 데이터 모델링을 완성
2. 데이터베이스 용량 산정
3. 데이터가 처리되는 테이블에 대해 트랜잭션 처리 패턴을 분석
4. 칼럼 단위, 로우 단위로 집중된 처리가 발생했는지 분석하여 테이블을 분리하는 것을 검토

<br>

### sharding vs partitioning

> [참고](http://theeye.pe.kr/archives/1917)

- 파티셔닝이란 퍼포먼스, 가용성, 또는 정비용이성을 목적으로 데이터 요소들을 다수의 엔티티(table)로 쪼개는 행위
- 샤딩은 수평 파티셔닝
  - 0 ~ 10000 번 고객의 정보는 하나의 샤드에 저장하고 10001 ~ 20000 번 고객의 정보는 다른 샤드에 저장
  - 이 때 데이터 엑세스 패턴과 저장 공간 이슈(로드의 적절한 분산 , 데이터의 균등한 저장)를 고려하여 적절한 샤드키를 결정함
- 수직 파티셔닝이란
  - 하나의 엔티티에 저장된 데이터들을 다수의 엔티티들로 분리하는것
  - 데이터 유연성, 보안의 이슈 등을 이유로 다른 테이블로 분리 가능



<br>

## 데이터베이스 구조와 성능

- 물리적인 테이블에 FK 제약을 걸었을 때는 반드시 FK 인덱스를 생성하고
- FK 제약이 걸리지 않았을 때는 FK 인덱스를 생성하는 것을 기본으로 하되,
  발생되는 트랜잭션에 의해 거의 활용하지 않을 때만 FK 인덱스를 지움



<br>

## 분산 데이터베이스와 성능

- 이러한 경우에 효과적
  - 성능이 중요한 사이트
  - 공통코드, 기준정보, 마스터 데이터 등에 대한 분산환경 구성으로 성능이 좋아짐
  - 실시간 동기화가 요구되지 않을 때 (실시간 업무적 특징을 가져도 분산 DB 구축 가능)
  - 특정 서버에 부하가 집중될 때 부하 분산 가능
  - 백업 사이트 구성할 때



<br>

<br>

# 윈도우 함수



<br>

<br>

# 그룹 함수





<br>

<br>

# SQL 성능 향상

- 인덱스의 활용과 관계됨

<br>

### Index 구조

- B 트리
  - 자료 구조를 트리구조로 하여 검색의 효율을 증진시킴
- B+ 트리
  - 단말 노드를 찾기 위한 인덱스 세트, 단말 노드로만 구성된 순차세트로 구성됨
- Clustered 인덱스
  - 테이블에서 하나의 속성을 기준으로 정렬시켜 재구성한 뒤, 그 테이블을 토대로 인덱스를 만드는 방법
  - 그래서 테이블의 물리적 순서와 인덱스의 순서가 동일하게 됨
- Non Clustered 인덱스
  - 테이블을 재구성하지 않고, 데이터 주소를 이용하여 인덱스를 만든 뒤 주소값을 이용하여 검색하는 방법



<br>

<br>

# 절차형 SQL

1. PL / SQL

> 오라클의 절차적 프로그래밍을 가능하게 하는 트랜잭션 언어
>
> Block 구조로 되어있고, 블럭 내에는 DML 문장과 QUERY 문장, 그리고 절차형 언어(IF / LOOF) 등을 사용할 수 있음

2. T-SQL

> SQL Server를 제어하기 위한 언어



- 이 둘을 활용하여 저장모듈 개발 가능

  - 저장모듈이란 PL / SQL 문장을 데이터베이스 서버에 저장하여 사용자와 애플리케이션 사이에 공유할 수 있도록 만든 일종의 SQL 컴포넌트 프로그램이며, 완전한 실행 프로그램
  - 오라클의 저장모듈에는 Procedure, User Defined Function, Trigger가 있음

- 비교

  1. cnt 변수는 SCALAR 변수, 사용자의임시 데이터를 하나만 저장 할 수 있는 변수, 모든 데이터 유형 가능

  2. PL / SQL 에서 사용하는 SELECT 문은 결과값이 반드시 있어야 하고, 하나여야한다. T-SQL은 결과 값이 없어도 에러가 발생하지 않음

  3. T-SQL은 대입 연산자 '='를 사용하지만, PL/SQL은 대입연산자 ':='를 사용함

  4. OTHERS를 이용하여 에러처리가 가능하지만, 웬만하면 정확하게 처리하는게 좋음

