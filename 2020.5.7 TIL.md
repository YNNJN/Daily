## 탐욕 알고리즘의 동작 과정

1. 해 선택
   - 현재 상태에서 부분문제의 최적해 구함
   - 이를 부분해집합에 추가
2. 실행 가능성 검사
   - 새로운 부분해 집합이 실행 가능한지를 확인
   - 문제의 제약조건을 위반하지 않는지를 검사
3. 해 검사
   - 새로운 부분해 집합이 문제의 해가 되는지를 확인
   - 전체 문제의 해가 아직 완성 전이라면, 1의 해 선택부터 다시 시작



<br>

<br>

## Knapsack

- 가능한 한 비싼 물건을 배낭에 담아 들고나오는 문제
- 물건의 무게가 초과하지 않으면서 값이 최대가 되는 물건들을 담아야



<br>

- 가방에 넣거나 빼거나

- `부분집합에 포함되거나 안 되거나`의 문제와 꼴이 같음

  

  <br>

  ### 0-1 Knapsack 완전 검색 방법

  - 완전검색으로 물건들의 집합 S에 대한 부분집합을 구함
  - 부분집합의 총 무게가 W를 초과하는 집합들은 버리고, 나머지 집합에서 총 값이 가장 큰 집합을 선택 가능
  - 물건 개수가 증가하면 시간복잡도가 지수적으로 증가함
    - 부분집합의 개수가 2^n인 것처럼

  ### 0-1 Knapsack 탐욕적 방법

  - 비싼 것부터
  - 가벼운 것부터
  - 무게 당 값어치를 따로 나눠서
  - 다 안 됨. 그리디 알고리즘 쓸 때는 예외사항이 있는지를 먼저 살펴야

  ### Fractional Knapsack

  - 쉽게 가능





<br>

<br>

## 탐욕 알고리즘의 필수 요소

- 탐욕적 선택 속성
  - 탐욕적 선택은 최적해로 갈 수 있음을 보여라
  - 즉 탐욕적 선택은 항상 안전하다
- 최적 부분구조
  - 최적화 문제를 정형화하라
  - 하나의 선택을 하면 풀어야 할 하나의 하위 문제가 남음
- **`원문제의 최적해 = 탐욕적 선택 + 하위문제의 최적해`** 임을 증명하라
  - 선택할 때, 그리고 하위문제에서 예외가 없는지를 확인해야
  - 그렇지 않으면, 지역적으로는 만족하지만 전체에 대해서는 최적해를 구할 수 없는 경우 발생



<br>

- 탐욕 기법과 동적계획법의 비교

| 탐욕 기법                                                    | 동적계획법                                            |
| ------------------------------------------------------------ | ----------------------------------------------------- |
| 매 단계에서, 가장 좋게 보이는 것을 빠르게 선택한다 -> 지역 최적 선택(local optimal choice) | 매단계의 선택은 해결한 하위 문제의 해를 기반으로 한다 |
| 하위 문제를 풀기 전에 (탐욕적) 선택이 먼저 이루어진다        | 하위 문제가 우선 해결된다                             |
| Top-down 방식                                                | Bottom-up 방식                                        |
| 일반적등로 빠르고 간결하다                                   | 좀 더 느리고 복잡하다                                 |



<br>

- 대표적 탐욕 기법의 알고리즘들
  - **각 상태에서 지역적으로 가장 좋은 것을 고른다**는 측면에서 탐욕 기법이라 할 수 있음
  - **만든 데이터를 재사용한다**는 측면에서 DP의 개념도 포함함

| 알고리즘            | 목적                                                        | 설명                                                         | -      |
| ------------------- | ----------------------------------------------------------- | ------------------------------------------------------------ | ------ |
| Prim                | N개의 노드에 대한 최소신장트리(MST)를 찾는다                | 서브트리를 확장하면서 MST를 찾는다                           | 그래프 |
| Kruskal             | N개의 노드에 대한 최소신장트리(MST)를 찾는다                | 싸이클이 없는 서브그래프를 확장하면서 MST를 찾는다           | 그래프 |
| Dijkstra            | 주어진 정점에서 다른 정점들에 대한 최단경로를 찾는다        | 주어진 정점에서 가장 가까운 정점을 찾고, 그 다음의 정점을 반복해서 찾는다 | 그래프 |
| Huffman tree & code | 문서의 압축을 위해 문자들의 빈도수에 따라 코드값을 부여한다 | 출현 빈도가 낮은 문자부터 선택해서 이진트리를 완성하고 코드값을 부여한다 | 문자열 |





<br>

<br>

### Baby-gin문제

> 	1. 3장의 카드가 연속적 - run
>  	2. 3장의 카드가 동일한 번호 - triplet
>  	3. run과 triplet으로만 구성된 경우 baby-gin

<br>

1. 전체의 **완전 검색**으로 푸는 방법

   - 조합적 문제, 순열을 이용하여

   ```python
   '''
   입력 - 6자리 숫자를 받음
   나열 - 중복 포함해 6자리로 만들 수 있는 모든 경우의 수 나열함
   판단 - 앞 3자리, 뒤 3자리를 잘라 run과 triplet 여부를 판단함
   
   '''
   
   ```

   - 6자리 숫자 나열 방법

   ```python
   '''
   1. 순열
   	nPr = n * (n-1) * (n-2) * ... * (n-r+1)
   	nPn = n!
   	
   	1) 최소변경을 통한 방법
   		- 각각의 순열들은 이전의 상태에서 단지 두 개의 요소들 교환을 통해 생성
   	2) 재귀호출을 통한 방법1
   		- 교환을 통해 생성
   	3) 재귀호출을 통한 방법2
   		- 방문여부를 통해 생성
   	
   '''
   
   #M1
   perm(n,k)
       if (k == n) print_arr
       else
           for (i in k -> n-1)
         	    swap(k,i)
               perm(n,k+1)
               swap(k,i)
               
   #M2
   perm(k)
       if (k == n) print_arr()
     	else
           for i in (i: 0 ~ n-1)
               if not visited[i]
                   t[k] = arr[i]
                   visited[i] = True
                   perm(k+1)
                   visited[i] = False
   
   ```

   ```python
   '''
   2. 조합
   	nCr = n! /(n-r)! r!
   	nCr = n-1Cr-1 + n-1Cr => 재귀적 표현 #inductive
   	nC0 = 1 #base
   	
   	1) 재귀호출을 통한 방법1
   	2) 재귀호출을 통한 방법2
   	
   '''
   
   #M1
   comb(n,k)
       if (r == 0) print_arr
       else if (n < r) return
       else
           t[r-1] = a[n-1]
           comb(n-1, r-1)
           comb(n-1, r)
   
   #M2
   comb(k,s) #depth, start
       if (k == r) print_arr
       else
           for (int i: s ~ n-r+k)
         	    t[k] = a[i]
               comb(k+1, i+1)
           
               
   ```

   ```python
   '''
   3. 부분집합
   	1) binary-counting
   	
   '''
   
   n = len(arr)
   for i in range(0, (1<<n)): #2^n
       for j in range(n):
           if i % (1 << j):
               print(f'{arr[j]}', end='')
       print()
   ```

   <br>

2. **Greedy**로 푸는 방법

   - 순열은 데이터 양이 많아지면 오래걸리니

   - Counts 배열의 각 원소를 체크하여 run과 triplet 및 baby-gin 여부를 판단함

   ```python
   i <-0, inp <- 0, tri <- 0, run <- 0
   inp <- input_6_numbers()
   c[12] <- {0,}
   
   while i < 6
       c[inp % 10] <- c[inp % 10] + 1
       inp <- inp // 10
       i += 1
       
   i <- 0
   while i < 10
       if c[i] >= 3
           c[i] <- c[i] - 3
           tri += 1
           continue
       if c[i] >= 1 and c[i+1] >= 1 and c[i+2] >= 1
           c[i] <- c[i] - 1
           c[i+1] <- c[i+1] - 1
           c[i+2] <- c[i+2] - 1
           run += 1
           continue
       i += 1
       
   if run + tri == 2: print('Baby Gin')
   else: print('Lose')
     
   ```

   